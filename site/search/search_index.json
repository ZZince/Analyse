{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Comparaison des vitesses d'ex\u00e9cution des algorithmes de tri","text":""},{"location":"#introduction","title":"Introduction","text":"<p>Dans ce document, nous allons comparer la performance de quatre algorithmes de tri : tri par s\u00e9lection, tri par insertion, tri fusion et tri rapide. L'objectif est de mesurer et d'analyser leurs vitesses d'ex\u00e9cution en fonction de la taille des donn\u00e9es. Chaque mesure a \u00e9t\u00e9 r\u00e9alis\u00e9 gr\u00e2ce au fichier tris.py dans lequel chaque tri est impl\u00e9ment\u00e9 et le programme principal de mesure est d\u00e9cris.</p>"},{"location":"#algorithmes-etudies","title":"Algorithmes \u00e9tudi\u00e9s","text":""},{"location":"#1-tri-par-selection","title":"1. Tri par s\u00e9lection","text":"<p>Le tri par s\u00e9lection consiste \u00e0 parcourir la liste pour trouver le plus petit \u00e9l\u00e9ment afin de le placer en premi\u00e8re position, puis \u00e0 parcourir \u00e0 nouveau la liste pour trouver le deuxi\u00e8me plus petit \u00e9l\u00e9ment et le placer en deuxi\u00e8me position, et ainsi de suite jusqu'\u00e0 ce que l'int\u00e9gralit\u00e9 du tableau soit tri\u00e9e. - Complexit\u00e9 Temps : O(n\u00b2) - Complexit\u00e9 M\u00e9moire : O(1) - Avantages : Simple \u00e0 impl\u00e9menter, efficace pour les petites listes. - Inconv\u00e9nients : Lent sur les grandes listes.  </p> <pre><code>  proc\u00e9dure tri_selection(tableau t)\n      n \u2190 longueur(t) \n      pour i de 0 \u00e0 n - 2\n          min \u2190 i       \n          pour j de i + 1 \u00e0 n - 1\n              si t[j] &lt; t[min], alors min \u2190 j\n          fin pour\n          si min \u2260 i, alors \u00e9changer t[i] et t[min]\n      fin pour\n  fin proc\u00e9dure\n</code></pre> <p> Sur ce graphique on observe bien l'allure quadratique de la courbe qui met environs 0,5 secondes \u00e0 trier une liste de 10 000 \u00e9l\u00e9ments mais aussi 2,25 secondes \u00e0 trier une liste de 20 000 \u00e9l\u00e9ments, soit presque 4 fois plus longtemps qu'un algorithme lin\u00e9aire</p>"},{"location":"#2-tri-par-insertion","title":"2. Tri par insertion","text":"<p>Le tri par insertion fonctionne en construisant progressivement une liste tri\u00e9e en ins\u00e9rant un \u00e9l\u00e9ment \u00e0 la fois dans sa position correcte.</p> <ul> <li>Complexit\u00e9 Temps : O(n\u00b2)</li> <li>Complexit\u00e9 M\u00e9moire : O(1)</li> <li>Avantages : Simple \u00e0 impl\u00e9menter, efficace pour les petites listes.</li> <li>Inconv\u00e9nients : Lent sur les grandes listes. </li> </ul> <pre><code>  proc\u00e9dure tri_insertion(tableau T)\n\n       pour i de 1 \u00e0 taille(T) - 1\n\n            # m\u00e9moriser T[i] dans x\n            x \u2190 T[i]                            \n\n            # d\u00e9caler les \u00e9l\u00e9ments T[0]..T[i-1] qui sont plus grands que x, en partant de T[i-1]\n            j \u2190 i                               \n            tant que j &gt; 0 et T[j - 1] &gt; x\n                     T[j] \u2190 T[j - 1]\n                     j \u2190 j - 1\n\n            # placer x dans le \"trou\" laiss\u00e9 par le d\u00e9calage\n            T[j] \u2190 x \n</code></pre> <p> Cette courbe a la m\u00eame allure que celle du tri par s\u00e9lection mais il est nettement plus rapide, l\u00e0 o\u00fb le tri par s\u00e9lection triais une liste de 20 000 \u00e9l\u00e9ments en 2,25 secondes, le tri par insertion met quant \u00e0 lui environs 1,7 secondes. </p>"},{"location":"#3-tri-fusion","title":"3. Tri Fusion","text":"<p>Le tri fusion consiste comme son nom l'indique en la fusion de petite liste tri\u00e9e chacune s\u00e9paremment en utilisant la r\u00e9cursivit\u00e9. - Complexit\u00e9 Temps : O(nlog(n)) - Complexit\u00e9 M\u00e9moire : O(n) - Avantages : Efficace sur les grandes listes. - Inconv\u00e9nients : N\u00e9cessite de la m\u00e9moire suppl\u00e9mentaire et \"lent\" sur les petites listes. </p> <pre><code>entr\u00e9e : un tableau T\nsortie : une permutation tri\u00e9e de T\nfonction triFusion(T[1, \u2026, n])\n      si n \u2264 1\n              renvoyer T\n      sinon\n              renvoyer fusion(triFusion(T[1, \u2026, n/2]), triFusion(T[n/2 + 1, \u2026, n]))\n</code></pre> <pre><code>entr\u00e9e : deux tableaux tri\u00e9s A et B\nsortie : un tableau tri\u00e9 qui contient exactement les \u00e9l\u00e9ments des tableaux A et B\nfonction fusion(A[1, \u2026, a], B[1, \u2026, b])\n      si A est le tableau vide\n              renvoyer B\n      si B est le tableau vide\n              renvoyer A\n      si A[1] \u2264 B[1]\n              renvoyer A[1] \u2295 fusion(A[2, \u2026, a], B)\n      sinon\n              renvoyer B[1] \u2295 fusion(A, B[2, \u2026, b])\n</code></pre> <p> La pente de cette courbe est moins abrupte que celle des tris par s\u00e9lection et par insertion, car le tri fusion a une complexit\u00e9 inf\u00e9rieure. Cependant, sur de petites listes, le tri par insertion peut \u00eatre plus rapide. Il existe tout de m\u00eame un point pivot \u00e0 partir duquel, pour un nombre suffisamment grand d'\u00e9l\u00e9ments, le tri fusion devient plus performant que le tri par insertion, en raison de sa meilleure complexit\u00e9 pour les grandes entr\u00e9es.  Le tri par insertion est effectivement plus rapide que le tri fusion sur des listes contenant moins de 1000 \u00e9l\u00e9ments mais la tendance s'inverse fortement par la suite, on retrouve le m\u00eame ph\u00e9nom\u00e9ne avec le tri par s\u00e9lection: </p>"},{"location":"#tri-rapide","title":"Tri rapide","text":"<p>Le tri rapide consiste en le partitionnement de la liste afin de placer des \u00e9l\u00e9ments pivots, d\u00e9j\u00e0 \u00e0 leur place d\u00e9finitive pour rediviser la liste encore et encore. - Complexit\u00e9 Temps : O(nlog(n)) - Complexit\u00e9 M\u00e9moire : O(log(n)) - Avantages : Tr\u00e8s rapide. - Inconv\u00e9nients : Compl\u00e9xit\u00e9 accrue si le pivot est mal choisi. </p> <pre><code>partitionner(tableau T, entier premier, entier dernier, entier pivot)\n    \u00e9changer T[pivot] et T[dernier]  // \u00e9change le pivot avec le dernier du tableau , le pivot devient le dernier du tableau\n    j := premier\n    pour i de premier \u00e0 dernier - 1 // la boucle se termine quand i = (dernier \u00e9l\u00e9ment du tableau).\n        si T[i] &lt;= T[dernier] alors\n            \u00e9changer T[i] et T[j]\n            j := j + 1\n    \u00e9changer T[dernier] et T[j]\n    renvoyer j\n</code></pre> <pre><code>tri_rapide(tableau T, entier premier, entier dernier)\n        si premier &lt; dernier alors\n            pivot := choix_pivot(T, premier, dernier)\n            pivot := partitionner(T, premier, dernier, pivot)\n            tri_rapide(T, premier, pivot-1)\n            tri_rapide(T, pivot+1, dernier)\n</code></pre> <p> On observe ici que le tri rapide est extr\u00e8mement efficace sur de grandes listes et a une \u00e9volution presque lin\u00e9aire en fonction du nombre d'\u00e9l\u00e9ments dans la liste. Cependant la vitesse de l'algorithme est tr\u00e8s d\u00e9pendante du bon choix du pivot, ce qui peut expliquer les irr\u00e9gularit\u00e9s dans les mesures de temps pour les listes \u00e0 15 000 \u00e9l\u00e9ments et plus.</p>"},{"location":"#comparaison-des-algorithmes","title":"Comparaison des algorithmes","text":"<p> En ce servant des pr\u00e9c\u00e9dents r\u00e9sultat il \u00e9tait \u00e0 pr\u00e9voir que l'algorithme le plus constant et le plus efficaces \u00e9taient le tri rapide, c'est d'ailleurs la m\u00e9thode de tri la plus utilis\u00e9 si on ne compte pas les algorithmes hybrides qui alternent entre plusieurs m\u00e9thodes de tri en fonction du nombre d'\u00e9l\u00e9ment par exemple. </p> <p>Aussi, jusqu'ici le cas o\u00fb la liste serai d\u00e9j\u00e0 tri\u00e9 n'a pas \u00e9t\u00e9 trait\u00e9, cependant cela est important \u00e0 prendre en compte puisque certains r\u00e9sultats changent radicalement:   Certains algorithme sont tr\u00e8s efficaces dans le cas o\u00fb la liste est d\u00e9j\u00e0 tri\u00e9es, notemment le tri par insertion, alors que d'autres tr\u00e8s efficaces dans des situations normales deviennent d'un coup tr\u00e8s lent par rapport aux autres comme le tri rapide. Dans certains cas il peut alors \u00eatre utile d'utiliser un pr\u00e9dicat afin de v\u00e9rifier si la liste est d\u00e9j\u00e0 tri\u00e9e ou partiellement tri\u00e9e d\u00e9s le d\u00e9but de l'algorithme.</p>"},{"location":"#comparaison-avec-la-methode-sort-de-python","title":"Comparaison avec la m\u00e9thode sort() de Python","text":"<p>Python met a disposition une m\u00e9thode de tri hybride via la m\u00e9thode sort() de la classe List ou la fonction sorted() qui renvoit une nouvelle liste tri\u00e9e en conservant la liste initiale en m\u00e9moire. Le tri fusion consiste comme son nom l'indique en la fusion de petite liste tri\u00e9e chacune s\u00e9paremment en utilisant la r\u00e9cursivit\u00e9. - Complexit\u00e9 Temps : O(nlog(n)) - Complexit\u00e9 M\u00e9moire : O(n) - Avantages : Efficace sur les grandes listes, efficace sur des listes d\u00e9j\u00e0 tri\u00e9es ou presque d\u00e9j\u00e0 tri\u00e9es, inclus dans Python par d\u00e9faut.  Le temps d'\u00e9x\u00e9cution de cette fonction est extr\u00eament bas, cela s'explique notemment car la fonction est \u00e9crite en C et permet donc des optimisations bas niveau non r\u00e9alis\u00e9es sur les fonctions \u00e9crites en Python. Il s'agit d'une solution simple et sans doute la meilleure pour trier des listes en Python. </p> <p>Sources:</p> <pre><code>https://fr.wikipedia.org/wiki/Tri_par_s%C3%A9lection\nhttps://fr.wikipedia.org/wiki/Tri_par_insertion\nhttps://fr.wikipedia.org/wiki/Tri_fusion\nhttps://fr.wikipedia.org/wiki/Tri_rapide\nhttps://docs.python.org/fr/3/howto/sorting.html\n</code></pre>"}]}