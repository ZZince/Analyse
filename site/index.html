<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="description" content="None" />
      <link rel="shortcut icon" href="img/favicon.ico" />
    <title>Analyse</title>
    <link rel="stylesheet" href="css/theme.css" />
    <link rel="stylesheet" href="css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Comparaison des vitesses d\u0027ex\u00e9cution des algorithmes de tri";
        var mkdocs_page_input_path = "index.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="." class="icon icon-home"> Analyse
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="./search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
                <li class="toctree-l1 current"><a class="reference internal current" href="#">Comparaison des vitesses d'exécution des algorithmes de tri</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#algorithmes-etudies">Algorithmes étudiés</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#1-tri-par-selection">1. Tri par sélection</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#2-tri-par-insertion">2. Tri par insertion</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#3-tri-fusion">3. Tri Fusion</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#tri-rapide">Tri rapide</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#comparaison-des-algorithmes">Comparaison des algorithmes</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#comparaison-avec-la-methode-sort-de-python">Comparaison avec la méthode sort() de Python</a>
    </li>
    </ul>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href=".">Analyse</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Comparaison des vitesses d'exécution des algorithmes de tri</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="comparaison-des-vitesses-dexecution-des-algorithmes-de-tri">Comparaison des vitesses d'exécution des algorithmes de tri</h1>
<h2 id="introduction">Introduction</h2>
<p>Dans ce document, nous allons comparer la performance de quatre algorithmes de tri : <strong>tri par sélection</strong>, <strong>tri par insertion</strong>, <strong>tri fusion</strong> et <strong>tri rapide</strong>. L'objectif est de mesurer et d'analyser leurs vitesses d'exécution en fonction de la taille des données.
Chaque mesure a été réalisé grâce au fichier tris.py dans lequel chaque tri est implémenté et le programme principal de mesure est décris.</p>
<h2 id="algorithmes-etudies">Algorithmes étudiés</h2>
<h3 id="1-tri-par-selection">1. Tri par sélection</h3>
<p>Le tri par sélection consiste à parcourir la liste pour trouver le plus petit élément afin de le placer en première position, puis à parcourir à nouveau la liste pour trouver le deuxième plus petit élément et le placer en deuxième position, et ainsi de suite jusqu'à ce que l'intégralité du tableau soit triée.
- <strong>Complexité Temps</strong> : O(n²)
- <strong>Complexité Mémoire</strong> : O(1)
- <strong>Avantages</strong> : Simple à implémenter, efficace pour les petites listes.
- <strong>Inconvénients</strong> : Lent sur les grandes listes.  </p>
<pre><code class="language-pseudo">  procédure tri_selection(tableau t)
      n ← longueur(t) 
      pour i de 0 à n - 2
          min ← i       
          pour j de i + 1 à n - 1
              si t[j] &lt; t[min], alors min ← j
          fin pour
          si min ≠ i, alors échanger t[i] et t[min]
      fin pour
  fin procédure
</code></pre>
<p><img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri par sélection" src="ressources/tri_selection_20000%2Belt.png" />
Sur ce graphique on observe bien l'allure quadratique de la courbe qui met environs 0,5 secondes à trier une liste de 10 000 éléments mais aussi 2,25 secondes à trier une liste de 20 000 éléments, soit presque 4 fois plus longtemps qu'un algorithme linéaire</p>
<h3 id="2-tri-par-insertion">2. Tri par insertion</h3>
<p>Le tri par insertion fonctionne en construisant progressivement une liste triée en insérant un élément à la fois dans sa position correcte.</p>
<ul>
<li><strong>Complexité Temps</strong> : O(n²)</li>
<li><strong>Complexité Mémoire</strong> : O(1)</li>
<li><strong>Avantages</strong> : Simple à implémenter, efficace pour les petites listes.</li>
<li><strong>Inconvénients</strong> : Lent sur les grandes listes. </li>
</ul>
<pre><code class="language-pseudo">  procédure tri_insertion(tableau T)

       pour i de 1 à taille(T) - 1

            # mémoriser T[i] dans x
            x ← T[i]                            

            # décaler les éléments T[0]..T[i-1] qui sont plus grands que x, en partant de T[i-1]
            j ← i                               
            tant que j &gt; 0 et T[j - 1] &gt; x
                     T[j] ← T[j - 1]
                     j ← j - 1

            # placer x dans le &quot;trou&quot; laissé par le décalage
            T[j] ← x 
</code></pre>
<p><img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri par insertion" src="ressources/tri_insertion_20000%2Belt.png" />
Cette courbe a la même allure que celle du tri par sélection mais il est nettement plus rapide, là oû le tri par sélection triais une liste de 20 000 éléments en 2,25 secondes, le tri par insertion met quant à lui environs 1,7 secondes.
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri par insertion et tri par sélection" src="ressources/tri_insertion_tri_selection_20000%2Belt.png" /></p>
<h3 id="3-tri-fusion">3. Tri Fusion</h3>
<p>Le tri fusion consiste comme son nom l'indique en la fusion de petite liste triée chacune séparemment en utilisant la récursivité.
- <strong>Complexité Temps</strong> : O(nlog(n))
- <strong>Complexité Mémoire</strong> : O(n)
- <strong>Avantages</strong> : Efficace sur les grandes listes.
- <strong>Inconvénients</strong> : Nécessite de la mémoire supplémentaire et "lent" sur les petites listes. </p>
<pre><code class="language-pseudo">entrée : un tableau T
sortie : une permutation triée de T
fonction triFusion(T[1, …, n])
      si n ≤ 1
              renvoyer T
      sinon
              renvoyer fusion(triFusion(T[1, …, n/2]), triFusion(T[n/2 + 1, …, n]))
</code></pre>
<pre><code class="language-pseudo">entrée : deux tableaux triés A et B
sortie : un tableau trié qui contient exactement les éléments des tableaux A et B
fonction fusion(A[1, …, a], B[1, …, b])
      si A est le tableau vide
              renvoyer B
      si B est le tableau vide
              renvoyer A
      si A[1] ≤ B[1]
              renvoyer A[1] ⊕ fusion(A[2, …, a], B)
      sinon
              renvoyer B[1] ⊕ fusion(A, B[2, …, b])
</code></pre>
<p><img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri fusion" src="ressources/tri_fusion_20000%2Belt.png" />
La pente de cette courbe est moins abrupte que celle des tris par sélection et par insertion, car le tri fusion a une complexité inférieure. Cependant, sur de petites listes, le tri par insertion peut être plus rapide. Il existe tout de même un point pivot à partir duquel, pour un nombre suffisamment grand d'éléments, le tri fusion devient plus performant que le tri par insertion, en raison de sa meilleure complexité pour les grandes entrées.
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri fusion et tri insertion" src="ressources/tri_fusion_tri_insertion_2500%2Belt.png" />
Le tri par insertion est effectivement plus rapide que le tri fusion sur des listes contenant moins de 1000 éléments mais la tendance s'inverse fortement par la suite, on retrouve le même phénoméne avec le tri par sélection:
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri fusion et tri par sélection" src="ressources/tri_fusion_tri_selection_400%2Belt.png" /></p>
<h3 id="tri-rapide">Tri rapide</h3>
<p>Le tri rapide consiste en le partitionnement de la liste afin de placer des éléments pivots, déjà à leur place définitive pour rediviser la liste encore et encore.
- <strong>Complexité Temps</strong> : O(nlog(n))
- <strong>Complexité Mémoire</strong> : O(log(n))
- <strong>Avantages</strong> : Très rapide.
- <strong>Inconvénients</strong> : Compléxité accrue si le pivot est mal choisi. </p>
<pre><code class="language-pseudo">partitionner(tableau T, entier premier, entier dernier, entier pivot)
    échanger T[pivot] et T[dernier]  // échange le pivot avec le dernier du tableau , le pivot devient le dernier du tableau
    j := premier
    pour i de premier à dernier - 1 // la boucle se termine quand i = (dernier élément du tableau).
        si T[i] &lt;= T[dernier] alors
            échanger T[i] et T[j]
            j := j + 1
    échanger T[dernier] et T[j]
    renvoyer j
</code></pre>
<pre><code class="language-pseudo">tri_rapide(tableau T, entier premier, entier dernier)
        si premier &lt; dernier alors
            pivot := choix_pivot(T, premier, dernier)
            pivot := partitionner(T, premier, dernier, pivot)
            tri_rapide(T, premier, pivot-1)
            tri_rapide(T, pivot+1, dernier)
</code></pre>
<p><img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri rapide" src="ressources/tri_rapide_20000%2Belt.png" />
On observe ici que le tri rapide est extrèmement efficace sur de grandes listes et a une évolution presque linéaire en fonction du nombre d'éléments dans la liste. Cependant la vitesse de l'algorithme est très dépendante du bon choix du pivot, ce qui peut expliquer les irrégularités dans les mesures de temps pour les listes à 15 000 éléments et plus.</p>
<h2 id="comparaison-des-algorithmes">Comparaison des algorithmes</h2>
<p><img alt="Evolution du temps de calcul en fonction du nombre d'éléments de tous les tris" src="ressources/all_tri_20000%2B.png" />
En ce servant des précédents résultat il était à prévoir que l'algorithme le plus constant et le plus efficaces étaient le tri rapide, c'est d'ailleurs la méthode de tri la plus utilisé si on ne compte pas les algorithmes hybrides qui alternent entre plusieurs méthodes de tri en fonction du nombre d'élément par exemple.
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de tous les tris" src="ressources/all_tri_1600%2B.png" /></p>
<p>Aussi, jusqu'ici le cas oû la liste serai déjà trié n'a pas été traité, cependant cela est important à prendre en compte puisque certains résultats changent radicalement: 
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de tous les tris si la liste donnée est déjà triée" src="ressources/all_tri_20000%2B_deja_triee.png" />
Certains algorithme sont très efficaces dans le cas oû la liste est déjà triées, notemment le tri par insertion, alors que d'autres très efficaces dans des situations normales deviennent d'un coup très lent par rapport aux autres comme le tri rapide. Dans certains cas il peut alors être utile d'utiliser un prédicat afin de vérifier si la liste est déjà triée ou partiellement triée dés le début de l'algorithme.</p>
<h2 id="comparaison-avec-la-methode-sort-de-python">Comparaison avec la méthode sort() de Python</h2>
<p>Python met a disposition une méthode de tri hybride via la méthode sort() de la classe List ou la fonction sorted() qui renvoit une nouvelle liste triée en conservant la liste initiale en mémoire.
Le tri fusion consiste comme son nom l'indique en la fusion de petite liste triée chacune séparemment en utilisant la récursivité.
- <strong>Complexité Temps</strong> : O(nlog(n))
- <strong>Complexité Mémoire</strong> : O(n)
- <strong>Avantages</strong> : Efficace sur les grandes listes, efficace sur des listes déjà triées ou presque déjà triées, inclus dans Python par défaut.
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction sorted" src="ressources/sorted_20000%2B.png" />
Le temps d'éxécution de cette fonction est extrêment bas, cela s'explique notemment car la fonction est écrite en C et permet donc des optimisations bas niveau non réalisées sur les fonctions écrites en Python.
Il s'agit d'une solution simple et sans doute la meilleure pour trier des listes en Python.
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction sorted" src="ressources/all_tri%2Bsorted_20000%2B.png" /></p>
<p>Sources:</p>
<pre><code>https://fr.wikipedia.org/wiki/Tri_par_s%C3%A9lection
https://fr.wikipedia.org/wiki/Tri_par_insertion
https://fr.wikipedia.org/wiki/Tri_fusion
https://fr.wikipedia.org/wiki/Tri_rapide
https://docs.python.org/fr/3/howto/sorting.html
</code></pre>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="js/jquery-3.6.0.min.js"></script>
    <script>var base_url = ".";</script>
    <script src="js/theme_extra.js"></script>
    <script src="js/theme.js"></script>
      <script src="search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>

<!--
MkDocs version : 1.6.1
Build Date UTC : 2024-09-20 11:41:55.186597+00:00
-->
