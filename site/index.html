
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
      
      
      <link rel="icon" href="assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.5.35">
    
    
      
        <title>Analyse</title>
      
    
    
      <link rel="stylesheet" href="assets/stylesheets/main.35f28582.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL(".",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    <body dir="ltr">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#comparaison-des-vitesses-dexecution-des-algorithmes-de-tri" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="." title="Analyse" class="md-header__button md-logo" aria-label="Analyse" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            Analyse
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Comparaison des vitesses d'exécution des algorithmes de tri
            
          </span>
        </div>
      </div>
    </div>
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="." title="Analyse" class="md-nav__button md-logo" aria-label="Analyse" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    Analyse
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  <span class="md-ellipsis">
    Comparaison des vitesses d'exécution des algorithmes de tri
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="." class="md-nav__link md-nav__link--active">
        
  
  <span class="md-ellipsis">
    Comparaison des vitesses d'exécution des algorithmes de tri
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      Introduction
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#algorithmes-etudies" class="md-nav__link">
    <span class="md-ellipsis">
      Algorithmes étudiés
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Algorithmes étudiés">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-tri-par-selection" class="md-nav__link">
    <span class="md-ellipsis">
      1. Tri par sélection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-tri-par-insertion" class="md-nav__link">
    <span class="md-ellipsis">
      2. Tri par insertion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-tri-fusion" class="md-nav__link">
    <span class="md-ellipsis">
      3. Tri Fusion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tri-rapide" class="md-nav__link">
    <span class="md-ellipsis">
      Tri rapide
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comparaison-des-algorithmes" class="md-nav__link">
    <span class="md-ellipsis">
      Comparaison des algorithmes
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comparaison-avec-la-methode-sort-de-python" class="md-nav__link">
    <span class="md-ellipsis">
      Comparaison avec la méthode sort() de Python
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      Introduction
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#algorithmes-etudies" class="md-nav__link">
    <span class="md-ellipsis">
      Algorithmes étudiés
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Algorithmes étudiés">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#1-tri-par-selection" class="md-nav__link">
    <span class="md-ellipsis">
      1. Tri par sélection
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#2-tri-par-insertion" class="md-nav__link">
    <span class="md-ellipsis">
      2. Tri par insertion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#3-tri-fusion" class="md-nav__link">
    <span class="md-ellipsis">
      3. Tri Fusion
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tri-rapide" class="md-nav__link">
    <span class="md-ellipsis">
      Tri rapide
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comparaison-des-algorithmes" class="md-nav__link">
    <span class="md-ellipsis">
      Comparaison des algorithmes
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#comparaison-avec-la-methode-sort-de-python" class="md-nav__link">
    <span class="md-ellipsis">
      Comparaison avec la méthode sort() de Python
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


<h1 id="comparaison-des-vitesses-dexecution-des-algorithmes-de-tri">Comparaison des vitesses d'exécution des algorithmes de tri</h1>
<h2 id="introduction">Introduction</h2>
<p>Dans ce document, nous allons comparer la performance de quatre algorithmes de tri : <strong>tri par sélection</strong>, <strong>tri par insertion</strong>, <strong>tri fusion</strong> et <strong>tri rapide</strong>. L'objectif est de mesurer et d'analyser leurs vitesses d'exécution en fonction de la taille des données.
Chaque mesure a été réalisé grâce au fichier tris.py dans lequel chaque tri est implémenté et le programme principal de mesure est décris.</p>
<h2 id="algorithmes-etudies">Algorithmes étudiés</h2>
<h3 id="1-tri-par-selection">1. Tri par sélection</h3>
<p>Le tri par sélection consiste à parcourir la liste pour trouver le plus petit élément afin de le placer en première position, puis à parcourir à nouveau la liste pour trouver le deuxième plus petit élément et le placer en deuxième position, et ainsi de suite jusqu'à ce que l'intégralité du tableau soit triée.
- <strong>Complexité Temps</strong> : O(n²)
- <strong>Complexité Mémoire</strong> : O(1)
- <strong>Avantages</strong> : Simple à implémenter, efficace pour les petites listes.
- <strong>Inconvénients</strong> : Lent sur les grandes listes.  </p>
<pre><code class="language-pseudo">  procédure tri_selection(tableau t)
      n ← longueur(t) 
      pour i de 0 à n - 2
          min ← i       
          pour j de i + 1 à n - 1
              si t[j] &lt; t[min], alors min ← j
          fin pour
          si min ≠ i, alors échanger t[i] et t[min]
      fin pour
  fin procédure
</code></pre>
<p><img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri par sélection" src="ressources/tri_selection_20000%2Belt.png" />
Sur ce graphique on observe bien l'allure quadratique de la courbe qui met environs 0,5 secondes à trier une liste de 10 000 éléments mais aussi 2,25 secondes à trier une liste de 20 000 éléments, soit presque 4 fois plus longtemps qu'un algorithme linéaire</p>
<h3 id="2-tri-par-insertion">2. Tri par insertion</h3>
<p>Le tri par insertion fonctionne en construisant progressivement une liste triée en insérant un élément à la fois dans sa position correcte.</p>
<ul>
<li><strong>Complexité Temps</strong> : O(n²)</li>
<li><strong>Complexité Mémoire</strong> : O(1)</li>
<li><strong>Avantages</strong> : Simple à implémenter, efficace pour les petites listes.</li>
<li><strong>Inconvénients</strong> : Lent sur les grandes listes. </li>
</ul>
<pre><code class="language-pseudo">  procédure tri_insertion(tableau T)

       pour i de 1 à taille(T) - 1

            # mémoriser T[i] dans x
            x ← T[i]                            

            # décaler les éléments T[0]..T[i-1] qui sont plus grands que x, en partant de T[i-1]
            j ← i                               
            tant que j &gt; 0 et T[j - 1] &gt; x
                     T[j] ← T[j - 1]
                     j ← j - 1

            # placer x dans le &quot;trou&quot; laissé par le décalage
            T[j] ← x 
</code></pre>
<p><img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri par insertion" src="ressources/tri_insertion_20000%2Belt.png" />
Cette courbe a la même allure que celle du tri par sélection mais il est nettement plus rapide, là oû le tri par sélection triais une liste de 20 000 éléments en 2,25 secondes, le tri par insertion met quant à lui environs 1,7 secondes.
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri par insertion et tri par sélection" src="ressources/tri_insertion_tri_selection_20000%2Belt.png" /></p>
<h3 id="3-tri-fusion">3. Tri Fusion</h3>
<p>Le tri fusion consiste comme son nom l'indique en la fusion de petite liste triée chacune séparemment en utilisant la récursivité.
- <strong>Complexité Temps</strong> : O(nlog(n))
- <strong>Complexité Mémoire</strong> : O(n)
- <strong>Avantages</strong> : Efficace sur les grandes listes.
- <strong>Inconvénients</strong> : Nécessite de la mémoire supplémentaire et "lent" sur les petites listes. </p>
<pre><code class="language-pseudo">entrée : un tableau T
sortie : une permutation triée de T
fonction triFusion(T[1, …, n])
      si n ≤ 1
              renvoyer T
      sinon
              renvoyer fusion(triFusion(T[1, …, n/2]), triFusion(T[n/2 + 1, …, n]))
</code></pre>
<pre><code class="language-pseudo">entrée : deux tableaux triés A et B
sortie : un tableau trié qui contient exactement les éléments des tableaux A et B
fonction fusion(A[1, …, a], B[1, …, b])
      si A est le tableau vide
              renvoyer B
      si B est le tableau vide
              renvoyer A
      si A[1] ≤ B[1]
              renvoyer A[1] ⊕ fusion(A[2, …, a], B)
      sinon
              renvoyer B[1] ⊕ fusion(A, B[2, …, b])
</code></pre>
<p><img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri fusion" src="ressources/tri_fusion_20000%2Belt.png" />
La pente de cette courbe est moins abrupte que celle des tris par sélection et par insertion, car le tri fusion a une complexité inférieure. Cependant, sur de petites listes, le tri par insertion peut être plus rapide. Il existe tout de même un point pivot à partir duquel, pour un nombre suffisamment grand d'éléments, le tri fusion devient plus performant que le tri par insertion, en raison de sa meilleure complexité pour les grandes entrées.
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri fusion et tri insertion" src="ressources/tri_fusion_tri_insertion_2500%2Belt.png" />
Le tri par insertion est effectivement plus rapide que le tri fusion sur des listes contenant moins de 1000 éléments mais la tendance s'inverse fortement par la suite, on retrouve le même phénoméne avec le tri par sélection:
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri fusion et tri par sélection" src="ressources/tri_fusion_tri_selection_400%2Belt.png" /></p>
<h3 id="tri-rapide">Tri rapide</h3>
<p>Le tri rapide consiste en le partitionnement de la liste afin de placer des éléments pivots, déjà à leur place définitive pour rediviser la liste encore et encore.
- <strong>Complexité Temps</strong> : O(nlog(n))
- <strong>Complexité Mémoire</strong> : O(log(n))
- <strong>Avantages</strong> : Très rapide.
- <strong>Inconvénients</strong> : Compléxité accrue si le pivot est mal choisi. </p>
<pre><code class="language-pseudo">partitionner(tableau T, entier premier, entier dernier, entier pivot)
    échanger T[pivot] et T[dernier]  // échange le pivot avec le dernier du tableau , le pivot devient le dernier du tableau
    j := premier
    pour i de premier à dernier - 1 // la boucle se termine quand i = (dernier élément du tableau).
        si T[i] &lt;= T[dernier] alors
            échanger T[i] et T[j]
            j := j + 1
    échanger T[dernier] et T[j]
    renvoyer j
</code></pre>
<pre><code class="language-pseudo">tri_rapide(tableau T, entier premier, entier dernier)
        si premier &lt; dernier alors
            pivot := choix_pivot(T, premier, dernier)
            pivot := partitionner(T, premier, dernier, pivot)
            tri_rapide(T, premier, pivot-1)
            tri_rapide(T, pivot+1, dernier)
</code></pre>
<p><img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction de tri rapide" src="ressources/tri_rapide_20000%2Belt.png" />
On observe ici que le tri rapide est extrèmement efficace sur de grandes listes et a une évolution presque linéaire en fonction du nombre d'éléments dans la liste. Cependant la vitesse de l'algorithme est très dépendante du bon choix du pivot, ce qui peut expliquer les irrégularités dans les mesures de temps pour les listes à 15 000 éléments et plus.</p>
<h2 id="comparaison-des-algorithmes">Comparaison des algorithmes</h2>
<p><img alt="Evolution du temps de calcul en fonction du nombre d'éléments de tous les tris" src="ressources/all_tri_20000%2B.png" />
En ce servant des précédents résultat il était à prévoir que l'algorithme le plus constant et le plus efficaces étaient le tri rapide, c'est d'ailleurs la méthode de tri la plus utilisé si on ne compte pas les algorithmes hybrides qui alternent entre plusieurs méthodes de tri en fonction du nombre d'élément par exemple.
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de tous les tris" src="ressources/all_tri_1600%2B.png" /></p>
<p>Aussi, jusqu'ici le cas oû la liste serai déjà trié n'a pas été traité, cependant cela est important à prendre en compte puisque certains résultats changent radicalement: 
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de tous les tris si la liste donnée est déjà triée" src="ressources/all_tri_20000%2B_deja_triee.png" />
Certains algorithme sont très efficaces dans le cas oû la liste est déjà triées, notemment le tri par insertion, alors que d'autres très efficaces dans des situations normales deviennent d'un coup très lent par rapport aux autres comme le tri rapide. Dans certains cas il peut alors être utile d'utiliser un prédicat afin de vérifier si la liste est déjà triée ou partiellement triée dés le début de l'algorithme.</p>
<h2 id="comparaison-avec-la-methode-sort-de-python">Comparaison avec la méthode sort() de Python</h2>
<p>Python met a disposition une méthode de tri hybride via la méthode sort() de la classe List ou la fonction sorted() qui renvoit une nouvelle liste triée en conservant la liste initiale en mémoire.
Le tri fusion consiste comme son nom l'indique en la fusion de petite liste triée chacune séparemment en utilisant la récursivité.
- <strong>Complexité Temps</strong> : O(nlog(n))
- <strong>Complexité Mémoire</strong> : O(n)
- <strong>Avantages</strong> : Efficace sur les grandes listes, efficace sur des listes déjà triées ou presque déjà triées, inclus dans Python par défaut.
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction sorted" src="ressources/sorted_20000%2B.png" />
Le temps d'éxécution de cette fonction est extrêment bas, cela s'explique notemment car la fonction est écrite en C et permet donc des optimisations bas niveau non réalisées sur les fonctions écrites en Python.
Il s'agit d'une solution simple et sans doute la meilleure pour trier des listes en Python.
<img alt="Evolution du temps de calcul en fonction du nombre d'éléments de la fonction sorted" src="ressources/all_tri%2Bsorted_20000%2B.png" /></p>
<p>Sources:</p>
<pre><code>https://fr.wikipedia.org/wiki/Tri_par_s%C3%A9lection
https://fr.wikipedia.org/wiki/Tri_par_insertion
https://fr.wikipedia.org/wiki/Tri_fusion
https://fr.wikipedia.org/wiki/Tri_rapide
https://docs.python.org/fr/3/howto/sorting.html
</code></pre>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    <script id="__config" type="application/json">{"base": ".", "features": [], "search": "assets/javascripts/workers/search.6ce7567c.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
      <script src="assets/javascripts/bundle.56dfad97.min.js"></script>
      
    
  </body>
</html>